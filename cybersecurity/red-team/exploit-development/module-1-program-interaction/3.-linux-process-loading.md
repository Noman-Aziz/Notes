# 3. Linux Process Loading

## [Slides Link](https://docs.google.com/presentation/d/1TwM5WLWnTqrNkpXjGKkaXYbKZEpatEQYA7ckBVXAOhs/edit?usp=sharing)

### Linux Process Features

1. State (running, waiting, zombie, stopped)
2. Priority (and other scheduling info)
3. Parent, siblings, children
4. Shared resources (files, pipes, sockets)
5. Virtual Memory Space
6. Security Context
   1. Effective uid and gid
   2. Saved uid and gid
   3. Capabilities

#### Processes come from

1. Fork
2. Clone
3. Execve

***

### Process Loading

#### 1. If file starts with `#!`

(script file), kernel extracts the interpreter from rest of that line and executes this interpreter with original file as an argument

#### 2. If file matches a format in `/proc/sys/fs/binfmt_misc`

kernel executes interpreter specified for that format with original file as an argument 1.  2. File extensions don't matter 3. We can also define cusom formats in this location like windows exe through wine

#### 3. If file is dynamically linked ELF

kernel read the interpreter/loader defined in the ELF, loads the interpreter and original file and let the interpreter take control 1. You can see interpreter of process using `readelf -a /bin/cat | grep interpret` aka loader 2. Can be overridden `/myinterpreter /bin/cat flag` 3. Can be changed permenetly using `patchelf --set-interpreter` 4. `LD_PRELOAD`, it gets loaded before any other libraries, to compile it use `gcc preload.gcc -shared -o preload.so` 5. `LD_LIBRARY_PATH` searches the required libraries in the specified path before looking at othe locations 6. `patchelf --set-rpath /whatever` can also be used to set the run path of the binary so that it also looks at this location along with LD\_LIBRARY\_PATH location 7. We can see memory space by looking at `/proc/self/maps` along with our binary like `./cat /proc/self/maps`

**libc.so**

It is a helper library used by almost every process e.g

1. printf()
2. scanf()
3. socket()
4. atoi()
5. malloc()
6. free()
7. etc

#### 4. If file is statically linked binary

1. The binary is loaded
2. Compiled with `gcc -static -o cat-static cat.c`
3. It has almost huge size since all libraries are shipped with the binary
4. Used in rust
5. Its virtual memory addresses are also static
   1. If we compile with `-static-pie`, then these virtual memory addresses also become dynamic

***

### Process Initialization

1. After process is loaded into memory, it is initialized
2. Every ELF binary can specify **constructors**, which are functions that run before program is actually launched
3. For example, libc can initialize memory regions for dynamic allocations (malloc/free) when program launches
4.  We can also specify our own

    1. ```c
       __attribute__((constructor)) void haha()
       {
       	puts("Hello World");
         //write(1, "haha\n", 5);
       }
       ```

    ```
    ```
5. Useful for using with LD\_PRELOAD files

***
