# 4. Linux Process Execution

## [Slides](https://docs.google.com/presentation/d/1ezY9Q8I0tzDD-7ZDXMbQM5RQ7z1dvB9-U\_nDEhc6qdE/edit#slide=id.g8a9f5b81a5\_0\_0)

### How Program is Launched

* A normal ELF automatically calls `__libc_start_main()` in libc, which in turns calls the program's main() function
* We can also create our own start main function which can be called using `LD_PRELOAD` argument
* Function Pointer Synax in C
  * ```c
    int __libc_start_main() {
    	int *(main) (int, char **, char **),
    	int argc,
    	char ** ubp_av,
    	void (*init) (void),
    	void (*fini) (void),
    	void (*rtld_fini)
    	(void), void (*stack_end)
    }
    {
    	puts("HELLO");
      exit(main(argc, ubp_av, 0));
    }
    ```
  * This is the function pointer syntax, like in first main there is a function pointer to main function which accepts arguments int, char \*\* and char \*\*

***

### Program reads it arguments and environment

Process entire input from outside, at launch, compromises of `int main(int argc, void **argv, void **envp);`

1. The loaded objects (binaries and libraries)
2. Command-line arguments in argv
3. Environment in envp

*   We can use `env` command to print envirtonmental variables

    * ```c
       int main(int argc, char **argc, char **envp)
       {
       	for (int i=0; envp[i] != 0; i++) puts(envp[i]);
       }
      ```

    ```bash
    - gcc env.c -o env
    -  ./env
    - FOO=BAR ./env
    ```
* To view all the library functions that a binary uses **imports**, we can use `nm -D <binary_name>` command&#x20;
* To view all the symbols that a binary **exports**, we can use `nm -a <binary_name>` command

***

### System Calls

* We can use `strace` command to look at system calls that a program executes
* We can use `syscall()` function in C to manually write syscalls like `syscall(1)` is used to write where `1` comes from `sys call table codes`
* System calls are way for process to call into the OS

***

### Signals

* Signals are way for OS to call the process
* Signal pause process execution and invoke the hnalder
* Handlers are functions that take one argument : the signal number
* Without handler, default action is often `kill`
* SIGKILL (signal 9) and SIGSTOP (signal 19) can not be handled
* Full list can be seen in section 7 of signal man i.e `man 7 signal` and `kill -l`

```c
int handler(int signal) {
	printf("Got signal number %d\n", signal);
}
int main() {
	for (int i=1; i<=64; i++) signal(i, handler);
	while(1);
}
```

* This program catches all the signals that you send like `CTRL+C`, `CTRL+Z`, etc and prints them.
* We can use `bg` and `fg` commands to bring stopped jobs to foreground and background a job

***

### Shared Memory

* Another way of interacting with outside is by shared memory with other processes.
* Requires system calls to establish, but once established, communication happens without system calls
* Easy Way : use a shared memory-mapped file in `/dev/shm`
  * Create file in `/dev/shm`
  * Use `mmap` command to setup shared memory of that file

***

### Process Termination

Processs terminates by one of two ways

1. Receiving an unhandled signal
2. Calling the exit() system call
